<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Split Screen Layout</title>
    <style>
        body, html {
            height: 100%;
            margin: 0;
            box-sizing: border-box;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 97%;
            width: 98%;
            padding: 10px; /* Padding for the entire layout */
            gap: 10px; /* Gap between the title and the content */
        }

        .title {
            height: 5%; /* Reduced height for the title section */
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid black;
            border-radius: 10px; /* Rounded corners */
            font-size: 1.2em;
            font-weight: bold;
            padding: 5px;
        }

        .content {
            display: flex;
            height: calc(95% - 10px); /* Remaining height for the rest of the content (subtracting gap) */
            width: 100%;
            gap: 10px; /* Gap between the sections */
        }

        .left, .middle {
            border-radius: 10px; /* Rounded corners for all main sections */
        }

        .left {
            flex: 1.5;
            display: flex;
            flex-direction: column;
            gap: 10px; /* Gap between top and bottom sections */
        }

        .left-top, .left-bottom {
            flex: 1;
            border: 1px solid black;
            border-radius: 10px; /* Rounded corners for internal sections */
        }

        .middle {
            flex: 3;
            display: flex;
            flex-direction: column;
            gap: 10px; /* Gap between top and bottom sections */
        }

        .middle-top {
            height: 25%;
            border: 1px solid black;
            border-radius: 10px; /* Rounded corners */
        }

        .middle-bottom {
            flex: 1;
            position: relative;
            border: 1px solid black;
            border-radius: 10px; /* Rounded corners */
        }

        .circle {
            width: 45%; /* Increased size to make it larger */
            height: 80%;
            border-radius: 50%;
            background-color: lightblue;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .rectangle {
            width: 12%; /* Increased width to make rectangles larger */
            height: 90%; /* Increased height for better visibility */
            background-color: lightgreen;
            position: absolute;
            border-radius: 10px; /* Rounded corners for rectangles */
        }

        .top-left {
            top: 5%;
            left: 2%;
        }

        .top-right {
            top: 5%;
            right: 2%;
        }

        .bottom-left {
            top: 5%;
            left: 15%;
        }

        .bottom-right {
            bottom: 5%;
            right: 15%;
        }

        .right {
            flex: 0.5;
            border: 1px solid black;
            border-radius: 10px; /* Rounded corners for the right part */
        }
/* chart title css */
.chart-title {
      margin-bottom: 10px;
      font-size: 14px;
      font-weight: bold;
      text-align: center;
    }

         /* Speedometer chart 1 */
    canvas {
  position: absolute;
  top: 30%;
  left: 14%;
  transform: translate(-50%, -50%);
}
.text {
  color: white;
  font-weight: 600;
  font-size: 24px;
  position: absolute;
  top: 35%;
  left: 14%;  transform: translate(-50%, -50%);
}
    </style>
</head>
<body>
    <div class="container">
        <div class="title">Split Screen Layout Title</div>
        <div class="content">
            <div class="left">
                <div class="left-top">
                    <div class="chart-title">Gauge</div>
                    <canvas id="canvas" height="175" width="350" class="m-auto">
                    </canvas>
                    <p class="text">0 %</p>
                </div>
                <div class="left-bottom"></div>
            </div>
            <div class="middle">
                <div class="middle-top"></div>
                <div class="middle-bottom">
                    <div class="circle"></div>
                    <div class="rectangle top-left"></div>
                    <div class="rectangle top-right"></div>
                    <div class="rectangle bottom-left"></div>
                    <div class="rectangle bottom-right"></div>
                </div>
            </div>
            <div class="right"></div>
        </div>
    </div>

    <script>
        window.onload = function() {
       // Sample data for 10 metrics
       const metrics = [
         { outcome: 50, target: 100 },  // Thermometer
         { outcome: 60, target: 100 },  // Battery
         { outcome: 30, target: 100 },  // Gauge
         { outcome: 40, target: 100 },  // Traffic Signal
         { outcome: 300, target: 500 }, // Rocket Launch
         { outcome: 50, target: 100 },  // Lift Metric
         { outcome: 100, target: 100 },  // Water Boat
         { outcome: 40, target: 100 },  // tree chart
         { outcome: 0, target: 100 },  // target chart
         { outcome: 60, target: 100 }   // Temperature Dial
       ];
   
       // Thermometer Fill
       setTimeout(() => {
         document.getElementById('thermometerFill').style.height = `${(metrics[0].outcome / metrics[0].target) * 100}%`;
       }, 100);
   
       // Battery Fill and Color
       const batteryFill = document.getElementById('batteryFill');
       const batteryContainer = document.getElementById('batteryContainer');
       const batteryPercentage = (metrics[1].outcome / metrics[1].target) * 100;
       setTimeout(() => {
         batteryFill.style.height = `${batteryPercentage}%`;
         if (batteryPercentage < 30) {
           batteryContainer.classList.add('low');
         } else if (batteryPercentage < 70) {
           batteryContainer.classList.add('medium');
         } else {
           batteryContainer.classList.add('high');
         }
       }, 100);
   
       // Gauge Needle
       //Change this Value to set the percentage
       let totalRot = ((metrics[2].outcome / metrics[2].target) * 180 * Math.PI) / 180;
   
       let rotation = 0;
       let doAnim = true;
       let canvas = null;
       let ctx = null;
       let text = document.querySelector(".text");
       canvas = document.getElementById("canvas");
       ctx = canvas.getContext("2d");
       setTimeout(requestAnimationFrame(animate), 1500);
   
       function calcPointsCirc(cx, cy, rad, dashLength) {
         var n = rad / dashLength,
           alpha = (Math.PI * 2) / n,
           pointObj = {},
           points = [],
           i = -1;
   
         while (i < n) {
           var theta = alpha * i,
             theta2 = alpha * (i + 1);
   
           points.push({
             x: Math.cos(theta) * rad + cx,
             y: Math.sin(theta) * rad + cy,
             ex: Math.cos(theta2) * rad + cx,
             ey: Math.sin(theta2) * rad + cy
           });
           i += 2;
         }
         return points;
       }
       function animate() {
         //Clearing animation on every iteration
         ctx.clearRect(0, 0, canvas.width, canvas.height);
         const center = {
           x: 175,
           y: 175
         };
   
         //main arc
         ctx.beginPath();
         ctx.lineWidth = "3";
         ctx.strokeStyle = rotation >= 0.50 * Math.PI && rotation <= 0.75 * Math.PI ? "orange" : "red";
         ctx.strokeStyle = rotation >= 0.75 * Math.PI ? "green" : "red";
         ctx.lineWidth = "3";
   
         let radius = 174;
         ctx.arc(center.x, center.y, radius, Math.PI, Math.PI + rotation);
         ctx.stroke();
   
   
         //Red Arc
         if (rotation <= 0.75 * Math.PI) {
           ctx.beginPath();
           ctx.strokeStyle = "green";
           ctx.lineWidth = "3";
           ctx.arc(center.x, center.y, radius, 1.75 * Math.PI, 0);
           ctx.stroke();
         }
   
         //functions to draw dotted lines
         const DrawDottedLine = (x1, y1, x2, y2, dotRadius, dotCount, dotColor) => {
           var dx = x2 - x1;
           var dy = y2 - y1;
           let slopeOfLine = dy / dx;
           var degOfLine =
             Math.atan(slopeOfLine) * (180 / Math.PI) > 0
               ? Math.atan(slopeOfLine) * (180 / Math.PI)
               : 180 + Math.atan(slopeOfLine) * (180 / Math.PI);
           var degOfNeedle = rotation * (180 / Math.PI);
   
           if (rotation >= 0.75 * Math.PI) {
             dotColor = degOfLine <= degOfNeedle ? "green" : "green";
           } else {
             dotColor = degOfLine <= degOfNeedle ? dotColor : "green";
           }
           var spaceX = dx / (dotCount - 1);
           var spaceY = dy / (dotCount - 1);
           var newX = x1;
           var newY = y1;
           for (var i = 0; i < dotCount; i++) {
             dotRadius = dotRadius >= 0.75 ? dotRadius - i * (0.5 / 15) : dotRadius;
             drawDot(newX, newY, dotRadius, `${dotColor}${100 - (i + 1)}`);
             newX += spaceX;
             newY += spaceY;
           }
         };
         const drawDot = (x, y, dotRadius, dotColor) => {
           ctx.beginPath();
           ctx.arc(x, y, dotRadius, 0, 2 * Math.PI, false);
           ctx.fillStyle = dotColor;
           ctx.fill();
         };
         let firstDottedLineDots = calcPointsCirc(center.x, center.y, 165, 1);
         for (let k = 0; k < firstDottedLineDots.length; k++) {
           let x = firstDottedLineDots[k].x;
           let y = firstDottedLineDots[k].y;
           DrawDottedLine(x, y, 175, 175, 1.75, 30, "green");
         }
   
         //dummy circle to hide the line connecting to center
         ctx.beginPath();
         ctx.arc(center.x, center.y, 80, 2 * Math.PI, 0);
         ctx.fillStyle = "black";
         ctx.fill();
   
         //Speedometer triangle
         var x = -75,
           y = 0;
         ctx.save();
         ctx.beginPath();
         ctx.translate(175, 175);
         ctx.rotate(rotation);
         ctx.moveTo(x, y);
         ctx.lineTo(x + 10, y - 10);
         ctx.lineTo(x + 10, y + 10);
         ctx.closePath();
         ctx.fillStyle = rotation >= 0.75 * Math.PI ? "green" : "red";
         ctx.fill();
         ctx.restore();
         if (rotation < totalRot) {
           rotation += (1 * Math.PI) / 180;
           if (rotation > totalRot) {
             rotation -= (1 * Math.PI) / 180;
           }
         }
   
         text.innerHTML = Math.round((rotation / Math.PI) * 100) + 0 + "%";
         requestAnimationFrame(animate);
       }
   
   
       // Traffic Signal
       const trafficOutcome = metrics[3].outcome / metrics[3].target;
       setTimeout(() => {
         if (trafficOutcome < 0.5) {
           document.getElementById('redLight').style.background = 'red';
         } else if (trafficOutcome < 0.75) {
           document.getElementById('yellowLight').style.background = 'yellow';
         } else {
           document.getElementById('greenLight').style.background = 'green';
         }
       }, 100);
   
       // Rocket Launch
       setTimeout(() => {
         document.getElementById('rocketImage').style.bottom = `${(metrics[4].outcome / metrics[4].target) * 100}%`;
       }, 100);
   
       // Lift Metric
       setTimeout(() => {
         document.getElementById('liftElevator').style.bottom = `${(metrics[5].outcome / metrics[5].target) * 100}%`;
       }, 100);
   
       // Water Boat Metric
       const boatElement = document.getElementById('boat');
       const boatMetric = metrics[6];
       const boatPercentage = (boatMetric.outcome / boatMetric.target) * 100;
       setTimeout(() => {
         if (boatPercentage >= 70) {
           boatElement.style.bottom =`50%`;

           boatElement.style.transform = `${70 + (boatPercentage / 100) * 20}%`;
         } else if (boatPercentage >= 30) {
           boatElement.style.bottom = `${50 + (boatPercentage / 100) * 20}%`;
           boatElement.style.transform = 'translateX(-50%) rotate(-3deg)';
         } else {
           boatElement.style.bottom = `${30 + (boatPercentage / 100) * 20}%`;
           boatElement.style.transform = 'translateX(-50%) rotate(-10deg)';
         }
       }, 100);
   
       // Canvas setup for the tree
       const treeCanvas = document.getElementById('treeCanvas2');
           const treeCtx = treeCanvas.getContext('2d');
           const fruit = treeCanvas.getContext('2d');
   
           // Growth parameters
           const outcomeValue = metrics[7].outcome;
           const targetValue = metrics[7].target;
           const growthRatio = outcomeValue / targetValue;
   
           // vec2 class definition for tree growth
           function vec2(x, y) {
               if (!(this instanceof vec2)) {
                   return new vec2(x, y);
               }
               this.x = x;
               this.y = y;
           }
           vec2.prototype.length = function () {
               return Math.sqrt(this.x * this.x + this.y * this.y);
           };
           vec2.direction = function (a) {
               return vec2(Math.cos(a), Math.sin(a));
           };
           vec2.prototype.sub = function (p) {
               this.x -= p.x; this.y -= p.y; return this;
           }
           vec2.prototype.add = function (p) {
               this.x += p.x; this.y += p.y; return this;
           }
           vec2.prototype.clone = function () {
               return vec2(this.x, this.y);
           };
           vec2.prototype.mul = function (v) {
               this.x *= v; this.y *= v; return this;
           };
           vec2.prototype.rotate = function (angle) {
               angle = angle * Math.PI / 180;
               const s = Math.sin(angle), c = Math.cos(angle);
               const a = this.clone();
               this.x = c * a.x - s * a.y;
               this.y = s * a.x + c * a.y;
               return this;
           };
   
           // Tree drawing setup
           let branches = [];
           const maxBranches = 500;
           const startPos = vec2(treeCanvas.width / 2, treeCanvas.height - 20);
           const initialDir = vec2(0, -1);
           const initialLength = 80; // Base trunk length
           branches.push(new Branch(startPos, initialDir, initialLength, 10)); // Add initial width of 10
   
           function Branch(pos, dir, length, width) {
               this.pos = pos;
               this.dir = dir;
               this.length = length;
               this.width = width; // Added width for the branch
               this.growth = 0; // Growth progress (0 to 1)
               this.hasSplit = false;
               this.to = pos.clone();
           }
   
           Branch.prototype.draw = function () {
               // Grow the branch
               if (this.growth < 1) {
                   this.growth += 0.02; // Growth speed
                   if (this.growth > 1) this.growth = 1;
                   this.to = this.pos.clone().add(this.dir.clone().mul(this.length * this.growth));
               }
   
               // Draw the branch with gradient color
               const gradient = treeCtx.createLinearGradient(this.pos.x, this.pos.y, this.to.x, this.to.y);
               gradient.addColorStop(0, "#8B4513");
               gradient.addColorStop(1, "#A0522D");
   
               treeCtx.strokeStyle = gradient;
               treeCtx.lineWidth = 35;
               treeCtx.beginPath();
               treeCtx.moveTo(this.pos.x, this.pos.y);
               treeCtx.lineTo(this.to.x, this.to.y);
               treeCtx.stroke();
   
    // Determine if branches or leaves should be added based on growthRatio
    if (this.growth === 1 && !this.hasSplit && branches.length < maxBranches) {
                   if (growthRatio >= 0.3 && this.width > 2) {
                       // Split branches only if outcome is >= 30%
                       this.hasSplit = true;
                       const newLength = this.length * 0.7; // New branches are shorter
                       const newWidth = this.width * 0.7; // New branches are thinner
                       const angleVariance = 20 * (1 - growthRatio); // Smaller angle deviation for higher growth ratio
   
                       branches.push(new Branch(this.to, this.dir.clone().rotate(-15 - angleVariance), newLength, newWidth));
                       branches.push(new Branch(this.to, this.dir.clone().rotate(15 + angleVariance), newLength, newWidth));
                   }
   
                   if (growthRatio >= 0.7 && this.width < 3) {
                       // Add leaves if outcome is >= 70%
                       drawLeaf(this.to.x, this.to.y, 20);
                       this.hasLeaves = true;
                   }
               }
   
               if (growthRatio >= 0.9 && this.growth === 1 && this.width < 3) {
                   // Add more leaves if outcome is >= 90%
                   drawLeaf(this.to.x + 5, this.to.y + 5, 30);
                   drawLeaf(this.to.x - 5, this.to.y - 5, 30);
                   this.hasLeaves = true;
               }
   
               if (growthRatio === 1 && this.growth === 1 && this.hasLeaves) {
                   // Add fruits if outcome equals target
                   drawFruit(this.to.x , this.to.y - 10);
                   drawFruit(this.to.x, this.to.y );
               }
           };
   
           // Function to draw leaves
           function drawLeaf(x, y, width) {
               treeCtx.fillStyle = "green";
               treeCtx.beginPath();
               treeCtx.arc(x, y, width, 0, Math.PI * 2); // Draw leaf as a small circle
               treeCtx.fill();
           }
   
           // Function to draw fruits
           function drawFruit(x, y) {
               fruit.fillStyle = "red";
               fruit.beginPath();
               fruit.arc(x, y, 10, 0, Math.PI * 2); // Draw fruit as a small red circle
               fruit.fill();
           }
   
           function drawTree() {
               treeCtx.clearRect(0, 0, treeCanvas.width, treeCanvas.height); // Clear canvas
   
               branches.forEach(branch => branch.draw());
   
               if (branches.length < maxBranches) {
                   requestAnimationFrame(drawTree);
               }
           }
   
           // Start tree drawing animation
           drawTree();
             // target chart
            
               const bulletHole = document.querySelector('.bullet-hole');
   
               
               // Choose the desired metric to display
               const selectedMetric = metrics[8];
   
               // Calculate the percentage of the outcome with respect to the target
               const percentage = (selectedMetric.outcome / selectedMetric.target) * 100;
   
               let x, y;
   
               // Special case: if outcome equals target, bullet hits dead center
               if (selectedMetric.outcome === selectedMetric.target) {
                   x = -13;
                   y = -13;
                   console.log("hi");
               } else {
                   // Otherwise, calculate position based on the percentage
                   const maxRadius = 150;
                   const minRadius = 0;
   
                   // Distance calculation
                   const distanceFromCenter = Math.max(minRadius, (100 - percentage) / 100 * maxRadius);
   
                   // Convert polar coordinates into Cartesian coordinates
                   const angle = Math.random() * 2 * Math.PI; // Random angle to make hits look natural
                   x = Math.cos(angle) * distanceFromCenter;
                   y = Math.sin(angle) * distanceFromCenter;
               }
   
               // Set bullet hole position based on calculated coordinates
               setTimeout(() => {
                   bulletHole.style.left = `calc(50% + ${x}px)`;
                   bulletHole.style.top = `calc(50% + ${y}px)`;
                   bulletHole.style.opacity = 1;
                   bulletHole.style.transform = 'scale(1)';
                   bulletHole.style.animation = 'bulletImpact 0.5s ease-in-out';
               }, 1000);
           
     //  car chart 
     const car = document.querySelector('#race-car');
   
               // Choose the desired metric to display
               const selectedMetric1 = metrics[7]; // Change this index to choose a different metric
   
               // Calculate the percentage of progress towards the target
               const percentage1 = (selectedMetric1.outcome / selectedMetric1.target) * 100;
   
               // Set car's position based on percentage1
               const trackWidth = document.querySelector('.race-container').offsetWidth;
               const maxPosition = trackWidth - 150; // Account for the width of the car SVG
               let finalPosition;
   
               // If outcome equals target, set position to finish line
               if (selectedMetric1.outcome === selectedMetric1.target) {
                   finalPosition = maxPosition; // Dead center at the finish line
               } else {
                   finalPosition = Math.min(maxPosition, (percentage1 / 100) * maxPosition);
               }
   
               // Move car to the calculated position
               setTimeout(() => {
                   car.style.transform = `translateX(${finalPosition}px)`;
               }, 500);
   
     }
     </script>
</body>
</html>
