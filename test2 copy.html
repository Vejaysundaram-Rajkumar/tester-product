<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Split Screen Layout</title>
    <style>
        body, html {
            height: 100%;
            margin: 0;
            box-sizing: border-box;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 97%;
            width: 98%;
            padding: 10px; /* Padding for the entire layout */
            gap: 10px; /* Gap between the title and the content */
        }

        .title {
            height: 5%; /* Reduced height for the title section */
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid black;
            border-radius: 10px; /* Rounded corners */
            font-size: 1.2em;
            font-weight: bold;
            padding: 5px;
        }

        .content {
            display: flex;
            height: calc(95% - 10px); /* Remaining height for the rest of the content (subtracting gap) */
            width: 100%;
            gap: 10px; /* Gap between the sections */
        }

        .left, .middle {
            border-radius: 10px; /* Rounded corners for all main sections */
        }

        .left {
            flex: 1.3;
            display: flex;
            flex-direction: column;
            gap: 10px; /* Gap between top and bottom sections */
        }

        .left-top, .left-bottom {
            flex: 1;
            border: 1px solid black;
            border-radius: 10px; /* Rounded corners for internal sections */
        }

        .middle {
            flex: 3;
            display: flex;
            flex-direction: column;
            gap: 10px; /* Gap between top and bottom sections */
        }

        .middle-top {
            height: 25%;
            border: 1px solid black;
            border-radius: 10px; /* Rounded corners */
        }

        .middle-bottom {
            flex: 1;
            position: relative;
            border: 1px solid black;
            border-radius: 10px; /* Rounded corners */
        }

        .circle {
            width: 45%; /* Increased size to make it larger */
            height: 80%;
            border-radius: 50%;
            background-color: lightblue;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .rectangle {
            width: 12%; /* Increased width to make rectangles larger */
            height: 90%; /* Increased height for better visibility */
            background-color: lightgreen;
            position: absolute;
            border-radius: 10px; /* Rounded corners for rectangles */
        }

        .top-left {
            top: 5%;
            left: 2%;
        }

        .top-right {
            top: 5%;
            right: 2%;
        }

        .bottom-left {
            top: 5%;
            left: 15%;
        }

        .bottom-right {
            bottom: 5%;
            right: 15%;
        }

        .right {
            flex: 0.5;
            border: 1px solid black;
            border-radius: 10px; /* Rounded corners for the right part */
        }

        /* Chart title CSS */
        .chart-title {
            margin-top: 10px;
            margin-left: 10px;
            margin-bottom: 10px;
            font-size: 24px;
            font-weight: bold;
            text-align: left;
        }

        /* Speedometer chart */
        canvas {
            position: absolute;
            top: 30%;
            left: 14%;
            transform: translate(-50%, -50%);
        }

        .text {
            color: white;
            font-weight: 600;
            font-size: 24px;
            position: absolute;
            top: 35%;
            left: 14%;
            transform: translate(-50%, -50%);
        }

        /* Water Boat Chart */
        .animation-wrapper {
            background: #ace5ee;
            position: absolute;
            width: 25%;
            height: 35%;
            left:19px;
            bottom:20px;
        }

        .water {
            bottom: 0;
            left: 0;
            position: absolute;
            width: 100%;
            height: 30%;
        }

        .water ul.waves {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .water ul.waves li {
            background-repeat: repeat-x;
            opacity: 0.7; /* Make the waves partially transparent */
        }

        .water ul.waves li.wave-one {
            animation: wave 8.7s linear infinite;
            bottom: 0;
            height: 50px;
            left: 0;
            position: absolute;
            right: 0;
            z-index: 10;
        }

        .water ul.waves li.wave-two {
            animation: wave 10s linear infinite;
            bottom: 0;
            height: 84px;
            left: 0;
            position: absolute;
            right: 0;
            z-index: 9;
        }

        .water ul.waves li.wave-three {
            animation: wave 25s linear infinite;
            bottom: 0;
            height: 190px;
            left: 0;
            position: absolute;
            right: 0;
            z-index: 8;
        }

        .water ul.waves li.wave-four {
            animation: wave 25s linear infinite;
            bottom: 0;
            height: 205px;
            left: 0;
            position: absolute;
            right: 0;
            opacity: 0.6; /* Further reduce opacity to better see the sinking boat */
        }

        .boat {
            animation: boat 3s linear infinite;
            background-repeat: no-repeat;
            bottom: 10%;
            left: 50%;
            position: absolute;
            transform: translateX(-50%);
            width: 250px;
            height: 140px;
            transition: bottom 3s ease-out, transform 3s ease-out;
        }

        @keyframes wave {
            0% {
                background-position: 0 0;
            }
            100% {
                background-position: 1920px 0;
            }
        }

        @keyframes boat {
            0% {
                transform: translateX(-50%) rotate(0);
            }
            50% {
                transform: translateX(-50%) rotate(-3deg);
            }
            100% {
                transform: translateX(-50%) rotate(0);
            }
        }
        /* car chart css */
        .race-container {
            position: relative;
            width: 100%;
            height: 110px;
            background: #444;
            border-radius: 20px;
            overflow: hidden;
            display: flex;
            align-items: center;
        }
        svg#race-car {
            position: absolute;
            width: 150px;
            height: auto;
            transition: transform 3s ease-in-out;
        }
        .finish-line {
            position: absolute;
            right: 0;
            height: 100%;
            width: 10px;
            background: repeating-linear-gradient(
                45deg,
                white,
                white 5px,
                black 5px,
                black 10px
            );
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="title">Split Screen Layout Title</div>
        <div class="content">
            <div class="left">
                <div class="left-top">
                    <div class="chart-title">Gauge</div>
                    <canvas id="canvas" height="175" width="350" class="m-auto"></canvas>
                    <p class="text">0 %</p>
                </div>
                <div class="left-bottom">
                    <div class="chart-title">Water Boat</div>
                    <div class="animation-wrapper">
                        <div class="water">
                            <ul class="waves">
                                <li class="wave-one" style="background-image: url('https://i.postimg.cc/7LtCC11Y/wave1.png');"></li>
                                <li class="wave-two" style="background-image: url('https://i.postimg.cc/P5hv05rh/wave2.png');"></li>
                                <li class="wave-three" style="background-image: url('https://i.postimg.cc/63Dyc91k/wave3.png');"></li>
                                <li class="wave-four" style="background-image: url('https://i.postimg.cc/1tg8DgM0/wave4.png');"></li>
                            </ul>
                        </div>
                        <div class="boat" id="boat" style="background-image: url('https://i.postimg.cc/GmQTRnHD/boat2.png');"></div>
                    </div>
                </div>
            </div>
            <div class="middle">
                <div class="middle-top">
                  <div class="chart-title">Temperature Dial</div>
      <div class="race-container">
        <!-- SVG of the car -->
        <svg id="race-car" viewBox="0 0 178 40" width="178" height="40">
            <path class="air" d="M 46 16.5 h -20 a 8 8 0 0 1 0 -16" fill="none" stroke="#E85725" stroke-width="1" stroke-linejoin="round" stroke-linecap="round"></path>
            <g id="car">
                <svg viewBox="0 0 118 28.125" x="30" y="11.725" width="118" height="28.125">
                    <defs>
                        <circle id="circle" cx="0" cy="0" r="1"></circle>
                        <g id="wheel">
                            <use href="#circle" fill="#1E191A" transform="scale(10)"></use>
                            <use href="#circle" fill="#fff" transform="scale(5)"></use>
                            <path fill="#1E191A" stroke="#1E191A" stroke-width="0.5" stroke-linecap="round" stroke-linejoin="round" opacity="0.2" stroke-dashoffset="0" d="M -3.5 0 a 4 4 0 0 1 7 0 a 3.5 3.5 0 0 0 -7 0"></path>
                            <use href="#circle" fill="#1E191A" transform="scale(1.5)"></use>
                            <path fill="none" stroke="#F9B35C" stroke-width="0.75" stroke-linecap="round" stroke-linejoin="round" stroke-dasharray="20 14 8 5" d="M 0 -7.5 a 7.5 7.5 0 0 1 0 15 a 7.5 7.5 0 0 1 0 -15"></path>
                            <path fill="none" stroke="#fff" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" opacity="0.1" stroke-dashoffset="0" d="M -6.5 -6.25 a 10 10 0 0 1 13 0 a 9 9 0 0 0 -13 0"></path>
                        </g>
                    </defs>
                    <g transform="translate(51.5 11.125)">
                        <path stroke-width="2" stroke="#1E191A" fill="#EF3F33" d="M 0 0 v -2 a 4.5 4.5 0 0 1 9 0 v 2"></path>
                        <rect fill="#1E191A" x="3.25" y="-3" width="5" height="3"></rect>
                    </g>
                    <g transform="translate(10 24.125)">
                        <g transform="translate(59 0)">
                            <path id="shadow" opacity="0.7" fill="#1E191A" d="M -64 0 l -4 4 h 9 l 8 -1.5 h 100 l -3.5 -2.5"></path>
                        </g>
                        <path fill="#fff" stroke="#1E191A" stroke-width="2.25" stroke-linecap="round" stroke-linejoin="round" d="M 0 0 v -10 l 35 -13 v 5 l 4 0.5 l 0.5 4.5 h 35.5 l 30 13"></path>
                        <g fill="#fff" stroke="#1E191A" stroke-width="2.25" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M -6 0 v -22 h 10 z"></path>
                            <path d="M 105 0 h -3 l -12 -5.2 v 6.2 h 12"></path>
                        </g>
                        <g fill="#949699" opacity="0.7">
                            <rect x="16" y="-6" width="55" height="6"></rect>
                            <path d="M 24 -14 l 13 -1.85 v 1.85"></path>
                        </g>
                    </g>
                    <g class="wheels" transform="translate(0 18.125)">
                        <g transform="translate(10 0)">
                            <use href="#wheel"></use>
                        </g>
                        <g transform="translate(87 0)">
                            <use href="#wheel" stroke-dashoffset="-22"></use>
                        </g>
                    </g>
                </svg>
            </g>
        </svg>
        <div class="finish-line"></div>
    </div>

    </div>
                <div class="middle-bottom">
                    <div class="circle"></div>
                    <div class="rectangle top-left"></div>
                    <div class="rectangle top-right"></div>
                    <div class="rectangle bottom-left"></div>
                    <div class="rectangle bottom-right"></div>
                </div>
            </div>
            <div class="right"></div>
        </div>
    </div>

    <script>
        window.onload = function() {
       // Sample data for 10 metrics
       const metrics = [
         { outcome: 50, target: 100 },  // Thermometer
         { outcome: 60, target: 100 },  // Battery
         { outcome: 90, target: 100 },  // Gauge
         { outcome: 40, target: 100 },  // Traffic Signal
         { outcome: 300, target: 500 }, // Rocket Launch
         { outcome: 50, target: 100 },  // Lift Metric
         { outcome: 10, target: 100 },  // Water Boat
         { outcome: 40, target: 100 },  // tree chart
         { outcome: 0, target: 100 },  // target chart
         { outcome: 60, target: 100 }   // Temperature Dial
       ];
   
       // Thermometer Fill
       setTimeout(() => {
         document.getElementById('thermometerFill').style.height = `${(metrics[0].outcome / metrics[0].target) * 100}%`;
       }, 100);
   
       // Battery Fill and Color
       const batteryFill = document.getElementById('batteryFill');
       const batteryContainer = document.getElementById('batteryContainer');
       const batteryPercentage = (metrics[1].outcome / metrics[1].target) * 100;
       setTimeout(() => {
         batteryFill.style.height = `${batteryPercentage}%`;
         if (batteryPercentage < 30) {
           batteryContainer.classList.add('low');
         } else if (batteryPercentage < 70) {
           batteryContainer.classList.add('medium');
         } else {
           batteryContainer.classList.add('high');
         }
       }, 100);
   
       // Gauge Needle
       //Change this Value to set the percentage
       let totalRot = ((metrics[2].outcome / metrics[2].target) * 180 * Math.PI) / 180;
   
       let rotation = 0;
       let doAnim = true;
       let canvas = null;
       let ctx = null;
       let text = document.querySelector(".text");
       canvas = document.getElementById("canvas");
       ctx = canvas.getContext("2d");
       setTimeout(requestAnimationFrame(animate), 1500);
   
       function calcPointsCirc(cx, cy, rad, dashLength) {
         var n = rad / dashLength,
           alpha = (Math.PI * 2) / n,
           pointObj = {},
           points = [],
           i = -1;
   
         while (i < n) {
           var theta = alpha * i,
             theta2 = alpha * (i + 1);
   
           points.push({
             x: Math.cos(theta) * rad + cx,
             y: Math.sin(theta) * rad + cy,
             ex: Math.cos(theta2) * rad + cx,
             ey: Math.sin(theta2) * rad + cy
           });
           i += 2;
         }
         return points;
       }
       function animate() {
         //Clearing animation on every iteration
         ctx.clearRect(0, 0, canvas.width, canvas.height);
         const center = {
           x: 175,
           y: 175
         };
   
         //main arc
         ctx.beginPath();
         ctx.lineWidth = "3";
         ctx.strokeStyle = rotation >= 0.50 * Math.PI && rotation <= 0.75 * Math.PI ? "orange" : "red";
         ctx.strokeStyle = rotation >= 0.75 * Math.PI ? "green" : "red";
         ctx.lineWidth = "3";
   
         let radius = 174;
         ctx.arc(center.x, center.y, radius, Math.PI, Math.PI + rotation);
         ctx.stroke();
   
   
         //Red Arc
         if (rotation <= 0.75 * Math.PI) {
           ctx.beginPath();
           ctx.strokeStyle = "green";
           ctx.lineWidth = "3";
           ctx.arc(center.x, center.y, radius, 1.75 * Math.PI, 0);
           ctx.stroke();
         }
   
         //functions to draw dotted lines
         const DrawDottedLine = (x1, y1, x2, y2, dotRadius, dotCount, dotColor) => {
           var dx = x2 - x1;
           var dy = y2 - y1;
           let slopeOfLine = dy / dx;
           var degOfLine =
             Math.atan(slopeOfLine) * (180 / Math.PI) > 0
               ? Math.atan(slopeOfLine) * (180 / Math.PI)
               : 180 + Math.atan(slopeOfLine) * (180 / Math.PI);
           var degOfNeedle = rotation * (180 / Math.PI);
   
           if (rotation >= 0.75 * Math.PI) {
             dotColor = degOfLine <= degOfNeedle ? "green" : "green";
           } else {
             dotColor = degOfLine <= degOfNeedle ? dotColor : "green";
           }
           var spaceX = dx / (dotCount - 1);
           var spaceY = dy / (dotCount - 1);
           var newX = x1;
           var newY = y1;
           for (var i = 0; i < dotCount; i++) {
             dotRadius = dotRadius >= 0.75 ? dotRadius - i * (0.5 / 15) : dotRadius;
             drawDot(newX, newY, dotRadius, `${dotColor}${100 - (i + 1)}`);
             newX += spaceX;
             newY += spaceY;
           }
         };
         const drawDot = (x, y, dotRadius, dotColor) => {
           ctx.beginPath();
           ctx.arc(x, y, dotRadius, 0, 2 * Math.PI, false);
           ctx.fillStyle = dotColor;
           ctx.fill();
         };
         let firstDottedLineDots = calcPointsCirc(center.x, center.y, 165, 1);
         for (let k = 0; k < firstDottedLineDots.length; k++) {
           let x = firstDottedLineDots[k].x;
           let y = firstDottedLineDots[k].y;
           DrawDottedLine(x, y, 175, 175, 1.75, 30, "green");
         }
   
         //dummy circle to hide the line connecting to center
         ctx.beginPath();
         ctx.arc(center.x, center.y, 80, 2 * Math.PI, 0);
         ctx.fillStyle = "black";
         ctx.fill();
   
         //Speedometer triangle
         var x = -75,
           y = 0;
         ctx.save();
         ctx.beginPath();
         ctx.translate(175, 175);
         ctx.rotate(rotation);
         ctx.moveTo(x, y);
         ctx.lineTo(x + 10, y - 10);
         ctx.lineTo(x + 10, y + 10);
         ctx.closePath();
         ctx.fillStyle = rotation >= 0.75 * Math.PI ? "green" : "red";
         ctx.fill();
         ctx.restore();
         if (rotation < totalRot) {
           rotation += (1 * Math.PI) / 180;
           if (rotation > totalRot) {
             rotation -= (1 * Math.PI) / 180;
           }
         }
   
         text.innerHTML = Math.round((rotation / Math.PI) * 100) + 0 + "%";
         requestAnimationFrame(animate);
       }
   
   
       // Traffic Signal
       const trafficOutcome = metrics[3].outcome / metrics[3].target;
       setTimeout(() => {
         if (trafficOutcome < 0.5) {
           document.getElementById('redLight').style.background = 'red';
         } else if (trafficOutcome < 0.75) {
           document.getElementById('yellowLight').style.background = 'yellow';
         } else {
           document.getElementById('greenLight').style.background = 'green';
         }
       }, 100);
   
       // Rocket Launch
       setTimeout(() => {
         document.getElementById('rocketImage').style.bottom = `${(metrics[4].outcome / metrics[4].target) * 100}%`;
       }, 100);
   
       // Lift Metric
       setTimeout(() => {
         document.getElementById('liftElevator').style.bottom = `${(metrics[5].outcome / metrics[5].target) * 100}%`;
       }, 100);
   
       // Water Boat Metric
       const boatElement = document.getElementById('boat');
       const boatMetric = metrics[6];
       const boatPercentage = (boatMetric.outcome / boatMetric.target) * 100;
       setTimeout(() => {
         if (boatPercentage >= 70) {
           boatElement.style.bottom = `70%`;
           boatElement.style.transform = `${150 + (boatPercentage / 100) * 20}%`
         } else if (boatPercentage >= 30) {
           boatElement.style.bottom = `${50 + (boatPercentage / 100) * 20}%`;
           boatElement.style.transform = 'translateX(-50%) rotate(-3deg)';
         } else {
           boatElement.style.bottom = `${30 + (boatPercentage / 100) * 20}%`;
           boatElement.style.transform = 'translateX(-50%) rotate(-10deg)';
         }
       }, 100);
   
       // Canvas setup for the tree
       const treeCanvas = document.getElementById('treeCanvas2');
           const treeCtx = treeCanvas.getContext('2d');
           const fruit = treeCanvas.getContext('2d');
   
           // Growth parameters
           const outcomeValue = metrics[7].outcome;
           const targetValue = metrics[7].target;
           const growthRatio = outcomeValue / targetValue;
   
           // vec2 class definition for tree growth
           function vec2(x, y) {
               if (!(this instanceof vec2)) {
                   return new vec2(x, y);
               }
               this.x = x;
               this.y = y;
           }
           vec2.prototype.length = function () {
               return Math.sqrt(this.x * this.x + this.y * this.y);
           };
           vec2.direction = function (a) {
               return vec2(Math.cos(a), Math.sin(a));
           };
           vec2.prototype.sub = function (p) {
               this.x -= p.x; this.y -= p.y; return this;
           }
           vec2.prototype.add = function (p) {
               this.x += p.x; this.y += p.y; return this;
           }
           vec2.prototype.clone = function () {
               return vec2(this.x, this.y);
           };
           vec2.prototype.mul = function (v) {
               this.x *= v; this.y *= v; return this;
           };
           vec2.prototype.rotate = function (angle) {
               angle = angle * Math.PI / 180;
               const s = Math.sin(angle), c = Math.cos(angle);
               const a = this.clone();
               this.x = c * a.x - s * a.y;
               this.y = s * a.x + c * a.y;
               return this;
           };
   
           // Tree drawing setup
           let branches = [];
           const maxBranches = 500;
           const startPos = vec2(treeCanvas.width / 2, treeCanvas.height - 20);
           const initialDir = vec2(0, -1);
           const initialLength = 80; // Base trunk length
           branches.push(new Branch(startPos, initialDir, initialLength, 10)); // Add initial width of 10
   
           function Branch(pos, dir, length, width) {
               this.pos = pos;
               this.dir = dir;
               this.length = length;
               this.width = width; // Added width for the branch
               this.growth = 0; // Growth progress (0 to 1)
               this.hasSplit = false;
               this.to = pos.clone();
           }
   
           Branch.prototype.draw = function () {
               // Grow the branch
               if (this.growth < 1) {
                   this.growth += 0.02; // Growth speed
                   if (this.growth > 1) this.growth = 1;
                   this.to = this.pos.clone().add(this.dir.clone().mul(this.length * this.growth));
               }
   
               // Draw the branch with gradient color
               const gradient = treeCtx.createLinearGradient(this.pos.x, this.pos.y, this.to.x, this.to.y);
               gradient.addColorStop(0, "#8B4513");
               gradient.addColorStop(1, "#A0522D");
   
               treeCtx.strokeStyle = gradient;
               treeCtx.lineWidth = 35;
               treeCtx.beginPath();
               treeCtx.moveTo(this.pos.x, this.pos.y);
               treeCtx.lineTo(this.to.x, this.to.y);
               treeCtx.stroke();
   
    // Determine if branches or leaves should be added based on growthRatio
    if (this.growth === 1 && !this.hasSplit && branches.length < maxBranches) {
                   if (growthRatio >= 0.3 && this.width > 2) {
                       // Split branches only if outcome is >= 30%
                       this.hasSplit = true;
                       const newLength = this.length * 0.7; // New branches are shorter
                       const newWidth = this.width * 0.7; // New branches are thinner
                       const angleVariance = 20 * (1 - growthRatio); // Smaller angle deviation for higher growth ratio
   
                       branches.push(new Branch(this.to, this.dir.clone().rotate(-15 - angleVariance), newLength, newWidth));
                       branches.push(new Branch(this.to, this.dir.clone().rotate(15 + angleVariance), newLength, newWidth));
                   }
   
                   if (growthRatio >= 0.7 && this.width < 3) {
                       // Add leaves if outcome is >= 70%
                       drawLeaf(this.to.x, this.to.y, 20);
                       this.hasLeaves = true;
                   }
               }
   
               if (growthRatio >= 0.9 && this.growth === 1 && this.width < 3) {
                   // Add more leaves if outcome is >= 90%
                   drawLeaf(this.to.x + 5, this.to.y + 5, 30);
                   drawLeaf(this.to.x - 5, this.to.y - 5, 30);
                   this.hasLeaves = true;
               }
   
               if (growthRatio === 1 && this.growth === 1 && this.hasLeaves) {
                   // Add fruits if outcome equals target
                   drawFruit(this.to.x , this.to.y - 10);
                   drawFruit(this.to.x, this.to.y );
               }
           };
   
           // Function to draw leaves
           function drawLeaf(x, y, width) {
               treeCtx.fillStyle = "green";
               treeCtx.beginPath();
               treeCtx.arc(x, y, width, 0, Math.PI * 2); // Draw leaf as a small circle
               treeCtx.fill();
           }
   
           // Function to draw fruits
           function drawFruit(x, y) {
               fruit.fillStyle = "red";
               fruit.beginPath();
               fruit.arc(x, y, 10, 0, Math.PI * 2); // Draw fruit as a small red circle
               fruit.fill();
           }
   
           function drawTree() {
               treeCtx.clearRect(0, 0, treeCanvas.width, treeCanvas.height); // Clear canvas
   
               branches.forEach(branch => branch.draw());
   
               if (branches.length < maxBranches) {
                   requestAnimationFrame(drawTree);
               }
           }
   
           // Start tree drawing animation
           drawTree();
             // target chart
            
               const bulletHole = document.querySelector('.bullet-hole');
   
               
               // Choose the desired metric to display
               const selectedMetric = metrics[8];
   
               // Calculate the percentage of the outcome with respect to the target
               const percentage = (selectedMetric.outcome / selectedMetric.target) * 100;
   
               let x, y;
   
               // Special case: if outcome equals target, bullet hits dead center
               if (selectedMetric.outcome === selectedMetric.target) {
                   x = -13;
                   y = -13;
                   console.log("hi");
               } else {
                   // Otherwise, calculate position based on the percentage
                   const maxRadius = 150;
                   const minRadius = 0;
   
                   // Distance calculation
                   const distanceFromCenter = Math.max(minRadius, (100 - percentage) / 100 * maxRadius);
   
                   // Convert polar coordinates into Cartesian coordinates
                   const angle = Math.random() * 2 * Math.PI; // Random angle to make hits look natural
                   x = Math.cos(angle) * distanceFromCenter;
                   y = Math.sin(angle) * distanceFromCenter;
               }
   
               // Set bullet hole position based on calculated coordinates
               setTimeout(() => {
                   bulletHole.style.left = `calc(50% + ${x}px)`;
                   bulletHole.style.top = `calc(50% + ${y}px)`;
                   bulletHole.style.opacity = 1;
                   bulletHole.style.transform = 'scale(1)';
                   bulletHole.style.animation = 'bulletImpact 0.5s ease-in-out';
               }, 1000);
           
     //  car chart 
     const car = document.querySelector('#race-car');
   
               // Choose the desired metric to display
               const selectedMetric1 = metrics[9]; // Change this index to choose a different metric
   
               // Calculate the percentage of progress towards the target
               const percentage1 = (selectedMetric1.outcome / selectedMetric1.target) * 100;
   
               // Set car's position based on percentage1
               const trackWidth = document.querySelector('.race-container').offsetWidth;
               const maxPosition = trackWidth - 150; // Account for the width of the car SVG
               let finalPosition;
   
               // If outcome equals target, set position to finish line
               if (selectedMetric1.outcome === selectedMetric1.target) {
                   finalPosition = maxPosition; // Dead center at the finish line
               } else {
                   finalPosition = Math.min(maxPosition, (percentage1 / 100) * maxPosition);
               }
   
               // Move car to the calculated position
               setTimeout(() => {
                   car.style.transform = `translateX(${finalPosition}px)`;
               }, 500);
   
     }
     </script>
</body>
</html>
